## This C++ application provides a way to display the contents of a .txt file.

### Data Structure Comparison Breakdown:
- [Cost Comparisons](https://github.com/CHenshaw010/Advising-Assistance-Program/blob/main/AdvisingAssistanceProgram_DataStructure_Examination.pdf)

### Description:
The problem to be solved in the projects was creating a program to be used by a university to keep track of course layouts. The course information included the course ID, course name, and zero or more prerequisites. This program would input/load course information from a CSV file into a binary search tree, hashtable, or vector and sort or display the information based on user input. The data structure chosen to implement in this program was a binary search tree.

### Usage:
When the program asks for a file name to import, it is referring to a .txt file within the project directory. As such, the default name is "ABCU_Advising_Program_Input.txt" which contains basic course information.

### Personal Notes:
- Most notably, this project expanded my approach to designing software in how I learned how valuable different data structures can be in different situations. Furthermore, the projects reinforced that a developer should never stop learning. While learning new techniques and approaches can be daunting, it can have measurable impacts and improvements to code so they should be explored.

- The projects have evolved the way I write programs by showing me it's not always beneficial to reinvent the wheel. Additionally, while complex solutions can show the expertise of a developer, they are likely too complex that it hinders the maintainability or readability of the code. Strategies that are tried-and-true are already well understood and using them boosts the programs maintainability as other developers would be able to immediately understand how the code functions. Furthermore, the research I did to provide the best solution highlighted improvements to syntax use, condition checks, and more in similar solutions. This allowed me to write more targeted code, reduce clutter, and provide more insightful comments to ensure the code was maintainable, readable, and adaptable.
